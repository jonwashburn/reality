import Mathlib
import IndisputableMonolith.Constants

namespace IndisputableMonolith
namespace UnitMapping

-- Minimal δ-ledger subgroup interface for decoupled mapping
namespace LedgerUnits

/-- Subgroup generated by δ (abstract placeholder using integers for mapping only). -/
def DeltaSub (δ : ℤ) := ℤ

@[simp] def fromZ (δ : ℤ) (n : ℤ) : DeltaSub δ := n
@[simp] def toZ   (δ : ℤ) (p : DeltaSub δ) : ℤ := p

@[simp] lemma toZ_fromZ (δ : ℤ) (hδ : δ ≠ 0) (n : ℤ) :
  toZ δ (fromZ δ n) = n := rfl

end LedgerUnits

open LedgerUnits

/-- Affine map from ℤ to ℝ: n ↦ slope·n + offset. -/
structure AffineMapZ where
  slope : ℝ
  offset : ℝ

@[simp] def apply (f : AffineMapZ) (n : ℤ) : ℝ := f.slope * (n : ℝ) + f.offset

/-- Map δ-subgroup to ℝ by composing the (stubbed) projection `toZ` with an affine map. -/
noncomputable def mapDelta (δ : ℤ) (hδ : δ ≠ 0) (f : AffineMapZ) : DeltaSub δ → ℝ :=
  fun p => f.slope * ((toZ δ p) : ℝ) + f.offset

lemma mapDelta_diff (δ : ℤ) (hδ : δ ≠ 0) (f : AffineMapZ)
  (p q : DeltaSub δ) :
  mapDelta δ hδ f p - mapDelta δ hδ f q
    = f.slope * ((toZ δ p - toZ δ q : ℤ) : ℝ) := by
  classical
  calc
    mapDelta δ hδ f p - mapDelta δ hδ f q
        = (f.slope * (toZ δ p : ℝ) + f.offset)
            - (f.slope * (toZ δ q : ℝ) + f.offset) := by
              simp [mapDelta]
    _   = f.slope * (toZ δ p : ℝ)
            - f.slope * (toZ δ q : ℝ) := by
              ring
    _   = f.slope * ((toZ δ p : ℝ)
            - (toZ δ q : ℝ)) := by
              simpa [mul_sub]
    _   = f.slope * ((toZ δ p - toZ δ q : ℤ) : ℝ) := by
              have hcast : ((toZ δ p - toZ δ q : ℤ) : ℝ)
                  = (toZ δ p : ℝ) - (toZ δ q : ℝ) := by
                    simpa using (Int.cast_sub (toZ δ p) (toZ δ q))
              simpa [hcast]

/-- Context constructors: charge (quantum `qe`) and time (τ0). -/
def chargeMap (qe : ℝ) : AffineMapZ := { slope := qe, offset := 0 }
def timeMap (U : Constants.RSUnits) : AffineMapZ := { slope := U.tau0, offset := 0 }

/-- WIP: action mapping requires Planck-like constant. Pass it explicitly. -/
def actionMap (hbar : ℝ) : AffineMapZ := { slope := hbar, offset := 0 }

/-- Existence of affine δ→charge mapping (no numerics). -/
noncomputable def mapDeltaCharge (δ : ℤ) (hδ : δ ≠ 0) (qe : ℝ) : DeltaSub δ → ℝ :=
  mapDelta δ hδ (chargeMap qe)

/-- Existence of affine δ→time mapping via τ0. -/
noncomputable def mapDeltaTime (δ : ℤ) (hδ : δ ≠ 0) (U : Constants.RSUnits) : DeltaSub δ → ℝ :=
  mapDelta δ hδ (timeMap U)

/-- Existence of affine δ→action mapping via an explicit ħ parameter. -/
noncomputable def mapDeltaAction (δ : ℤ) (hδ : δ ≠ 0) (hbar : ℝ) : DeltaSub δ → ℝ :=
  mapDelta δ hδ (actionMap hbar)

@[simp] lemma mapDelta_fromZ (δ : ℤ) (hδ : δ ≠ 0) (f : AffineMapZ) (n : ℤ) :
  mapDelta δ hδ f (fromZ δ n) = f.slope * (n : ℝ) + f.offset := by
  classical
  simp [mapDelta]

lemma mapDelta_step (δ : ℤ) (hδ : δ ≠ 0) (f : AffineMapZ) (n : ℤ) :
  mapDelta δ hδ f (fromZ δ (n+1)) - mapDelta δ hδ f (fromZ δ n) = f.slope := by
  classical
  calc
    mapDelta δ hδ f (fromZ δ (n+1))
      - mapDelta δ hδ f (fromZ δ n)
        = (f.slope * ((n+1 : ℤ) : ℝ) + f.offset)
            - (f.slope * (n : ℝ) + f.offset) := by
              simp [mapDelta]
    _   = f.slope * ((n+1 : ℤ) : ℝ) - f.slope * (n : ℝ) := by
              ring
    _   = f.slope * ((n : ℝ) + 1) - f.slope * (n : ℝ) := by
              simpa [Int.cast_add, Int.cast_one]
    _   = f.slope := by
              simp [mul_add, sub_eq_add_neg, add_comm, add_left_comm, add_assoc]

@[simp] lemma mapDeltaTime_fromZ (δ : ℤ) (hδ : δ ≠ 0)
  (U : Constants.RSUnits) (n : ℤ) :
  mapDeltaTime δ hδ U (fromZ δ n) = U.tau0 * (n : ℝ) := by
  classical
  have h := mapDelta_fromZ (δ:=δ) (hδ:=hδ) (f:=timeMap U) (n:=n)
  simpa [mapDeltaTime, timeMap, add_comm] using h

lemma mapDeltaTime_step (δ : ℤ) (hδ : δ ≠ 0)
  (U : Constants.RSUnits) (n : ℤ) :
  mapDeltaTime δ hδ U (fromZ δ (n+1)) - mapDeltaTime δ hδ U (fromZ δ n) = U.tau0 := by
  simpa [mapDeltaTime, timeMap] using
    (mapDelta_step (δ:=δ) (hδ:=hδ) (f:=timeMap U) (n:=n))

@[simp] lemma mapDeltaAction_fromZ (δ : ℤ) (hδ : δ ≠ 0)
  (hbar : ℝ) (n : ℤ) :
  mapDeltaAction δ hδ hbar (fromZ δ n) = hbar * (n : ℝ) := by
  classical
  have h := mapDelta_fromZ (δ:=δ) (hδ:=hδ) (f:=actionMap hbar) (n:=n)
  simpa [mapDeltaAction, actionMap, add_comm] using h

lemma mapDeltaAction_step (δ : ℤ) (hδ : δ ≠ 0)
  (hbar : ℝ) (n : ℤ) :
  mapDeltaAction δ hδ hbar (fromZ δ (n+1)) - mapDeltaAction δ hδ hbar (fromZ δ n)
    = hbar := by
  simpa [mapDeltaAction, actionMap] using
    (mapDelta_step (δ:=δ) (hδ:=hδ) (f:=actionMap hbar) (n:=n))

lemma mapDelta_diff_toZ (δ : ℤ) (hδ : δ ≠ 0) (f : AffineMapZ)
  (p q : DeltaSub δ) :
  mapDelta δ hδ f p - mapDelta δ hδ f q
    = f.slope * ((toZ δ p - toZ δ q : ℤ) : ℝ) := by
  classical
  simpa using (mapDelta_diff (δ:=δ) (hδ:=hδ) (f:=f) (p:=p) (q:=q))

end UnitMapping
end IndisputableMonolith


